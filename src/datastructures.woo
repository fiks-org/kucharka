.Chapter Datové struktury
  label: chap-datastructures


Určitě jste při programování na věci jako list, vector, queue, dict, map. To jsou datové typy, které v sobě
uchovávají další data, ke kterým můžeme přistupovat, případně přidávat, modifikovat, odebírat. Jsou to implementace "datových
struktur".notion.1, to jsou také implementace tentokrát více teoretické. Datové stuktury implementují
"abstraktní datové typy (ADT)".notion.2, matematické objekty umožňující uchovávání dat,
které mají přidružené různé funkce umožnující práci s daty uchovanými v nich. Tyto funkce mají určité matematické vlastnosti, jako
časovou a paměťovou složitost. Datová strukura pak přesně popisuje jak musí být data uložena a algoritmy funkcí, aby dosáhly
požadovaných vlastností. Datová stukruta pak je již založena na nějakém výpočetním modelu.
  1:
    index: datová struktura
  2:
    index: abstraktní datový typ


.Example:
  label: example-datastructures
  title: Příklad ADT, datové struktury a její implementace

  Ukážeme si na příkladu abstraktního datového typu $X$ udržujícího čísla, ten bude mít přidružené tři funkce. Funkci "vytvoř".emphasize,
  která vytvoří instanci s požadovanou kapacitou. Další "vlož".emphasize vloží prvek, a třetí "vezmi".emphasize bude prvky vyndavat v opačném pořadí než byly vloženy.
  Takže vlastně "FILO".quoted"first in last out".footnote fronta neboli stack.


  Datová struktura implemetující $X$ v RAM modelu pak ve funkci vytvoř naalokuje paměťové buňky na zapamatování si
  pozice prvního volného místa a nastaví ho na první buňku a pro uložení potřebného počtu prvků.
  Funkce "vlož".emphasize se podívá na buňku, kde je uloženo první volné místo,
  a na takovou pozici vloží prvek a inkrementuje pozici prvního volného místa o jedna.
  "vezmi".emphasize pak udělá opak "vlož".emphasize, decrementuje pozici prvního volného místa a vrátí prvek na této pozici.


  Implementace v C by pak vypadala nějak takto.


  !codeblock:
    language: c

    struct FILO {
        int prvni_volna;
        int * bunky;
    };
    struct FILO vytvor(int n){
        return {0, malloc(n*sizeof(int))}
    }
    void vloz(struct FILO * f, int p){
        f->bunky[f->prvni_volna++] = p;
    }
    int vezmi(struct FILO * f){
        return f->bunky[--f->prvni_volna];
    }


V této kapitole se budeme věnovat hlavně datovým strukturám v RAM modelu. Takže stále matematickým popisům, při diskusi výhod a nevýhod bude někdy
nutné podívat se na možnosti implementace na reálných počítačích, protože ač může vypadat nějaká datová struktura dobře svými vlastnostmi,
např. nejlepší časová složitost, hardwarová implementace dnešních počítačů je lepší pro matematicky méně optimální funkce.


.Section Lineární datové struktury
  label: sec-linear-datastructures


.Definition:
  title: Pole
  label: def-pole
  index: pole

  Není pole jako pole. Na tomto se rostliny nepěstují ani po něm traktor nejezdí. Je to nejjednodužžší
  datová struktura. Řada buňek za sebou. Do kterých můžeme přistupovat a modifikovat jejich obsah.

  
  Přístup i modifikaci prvků máme za $\lanO(1)$ jak v čase tak paměti. Přistupovat však můžeme pouze na index,
  pokud bychom potřebovali určitý prvek, tak budeme nuceni použít nějaký algoritmus z sekce .reference:sec-vyhledavaci-algo.


  Jeho implementace najdete v C jako "int[]".code, v Rustu "[u32; n]".code nebo Array v Csharp.


% TODO vymyslet jak psát C#


Pole je dobrý kamarád dokud víme předem, kolik prvků bude potřeba, když to ale nevíme tak potřebujeme něco lepšího.


.Definition:
  title: Nafukovací pole
  label: def-nafukovaci-pole
  index: nafukovací pole

  "Nafukovací pole".notion je pole, do kterého můžeme přistupovat na index za konstantní čas. Narozdíl od klasického pole však,
  nemusíme předem specifikovat velikost a můžeme do pole přidávat prvky. Prvky na konec vkládáme za amortizovaně konstantní čas.
  Kamkoli jinam za $\lanO(n)$


  Je to "list".code co znáte z Pythonu nebo vektory z C++ a Rustu.


.Definition:
  title: Spojový seznam
  english: Linked list
  index:
    - spojový seznam
    - linked list
  label: def-spojovy-seznam

  Spojový seznam umožňuje vkládání kamkoli za $\lanO(1)$. Ale přístup na index je za $\lanO(n)$


  V Rustu "std::collections::LinkedList".code a "std::list".code v C++.


.Definition:
  title: Zásobník
  english: Stack
  index:
    - zásobník
    - stack
  label: def-stack

  Zásobník neboli stack je jednoduchá struktura, umožňuje vložit prvek za $\lanO(1)$ a vyzvednout prvek, opět za $\lanO(1)$.
  Prvky se vyzvedávají v opačném pořadí od vložení.


.Definition:
  title: Fronta
  english: Queue
  index:
    - fronta
    - queue
  label: def-queue

  Fronta se chová podobně jako zásobník, také umožňuje vložit a vyzvednout prvek za $\lanO(1)$, ovšem prvky
  se vyzvedávají v pořadí v jakém se do fronty dostaly.

% Pole, nafukovací pole, spoják, stack, fronta, kruhový buffer, deque


.Section Hashování v datových strukturách
  label: sec-hash-in-datastractures


S pojmem hashování jste se spíše setkali v kontextu bezpečnosti, použít se však dá i v datových strukturách. Hashování je způsob
jak objekty, které nejsou jednoduše porovnatelné mezi sebou uspořádat tak, aby se dali rychle najít.


.Definition:
  title: Hashovací funkce
  index: hashovací funkce
  label: def-hash-fun

  Obecná hashovací funkce je $f\colon \UU \to \PP$ přiřadí každému objektu v univezu $\UU$ nějakou přihrádku v $\PP$.

  
  Prakticky to bude spíše $f\colon \UU \to \N$, kde se každému objektu přiřadí nějaké přirozené číslo a další funkce (třeba modulo počet přihrádek)
  z čísla zjistí přihrádku.



.Definition:
  title: Hash set
  index: hash!set
  label: def-hash-set

  Hash set je datová struktura reprezentující množinu, která zvládne vložit a odebrat prvek za $\lanO^*(1)$.
  Také umí odpovědět, zda se prvek v množině nachází za $\lanO^*(1)$.


  Naleznete ho jako "std::unoredered_set".code v C++, "std::collections::HashSet".code v Rustu nebo "set".code v Pythonu.


.Definition:
  title: Hash map
  index: hash!map
  label: def-hash-map

  Hash map je datová struktura, která ukládá dvojice $(\text{klíč}, \text{hodnota})$. Vložit je potřeba klíč s hodnotou za $\lanO^*(1)$.
  Na hodnotu se pak můžeme zeptat pouze za pomoci klíče opět za $\lanO^*(1)$. Hodnotu ke klíči můžeme změnit také za $\lanO^*(1)$.

  Naleznete ho jako "std::unoredered_map".code v C++, "std::collections::HashMap".code v Rustu nebo "dict".code v Pythonu.

% Hashtable, hashmap, dobré hashovací funkce


.Section Stromové struktury
  label: sec-tree-structures


BST, AVL, Redblack, Binary heap, AB-strom


% .Section Kombinované struktury
%   label: sec-combined-structures
%
%
% priority queue


.Section Pokročilé datové struktury
  label: sec-advanced-datastructures


Segtree, Fenwic tree, Trie, Union-Find, 
