.Chapter Datové struktury
  label: chap-datastructures


Určitě jste při programování na věci jako list, vector, queue, dict, map. To jsou datové typy, které v sobě
uchovávají další data, ke kterým můžeme přistupovat, případně přidávat, modifikovat, odebírat. Jsou to implementace "datových
struktur".notion.1, to jsou také implementace tentokrát více teoretické. Datové stuktury implementují
"abstraktní datové typy (ADT)".notion.2, matematické objekty umožňující uchovávání dat,
které mají přidružené různé funkce umožnující práci s daty uchovanými v nich. Tyto funkce mají určité matematické vlastnosti, jako
časovou a paměťovou složitost. Datová strukura pak přesně popisuje jak musí být data uložena a algoritmy funkcí, aby dosáhly
požadovaných vlastností. Datová stukruta pak je již založena na nějakém výpočetním modelu.
  1:
    index: datová struktura
  2:
    index: abstraktní datový typ


.Example:
  label: example-datastructures
  title: Příklad ADT, datové struktury a její implementace

  Ukážeme si na příkladu abstraktního datového typu $X$ udržujícího čísla, ten bude mít přidružené tři funkce. Funkci "vytvoř".emphasize,
  která vytvoří instanci s požadovanou kapacitou. Další "vlož".emphasize vloží prvek, a třetí "vezmi".emphasize bude prvky vyndavat v opačném pořadí než byly vloženy.
  Takže vlastně "FILO".quoted"first in last out".footnote fronta neboli stack.


  Datová struktura implemetující $X$ v RAM modelu pak ve funkci vytvoř naalokuje paměťové buňky na zapamatování si
  pozice prvního volného místa a nastaví ho na první buňku a pro uložení potřebného počtu prvků.
  Funkce "vlož".emphasize se podívá na buňku, kde je uloženo první volné místo,
  a na takovou pozici vloží prvek a inkrementuje pozici prvního volného místa o jedna.
  "vezmi".emphasize pak udělá opak "vlož".emphasize, decrementuje pozici prvního volného místa a vrátí prvek na této pozici.


  Implementace v C by pak vypadala nějak takto.


  !codeblock:
    language: c

    struct FILO {
        int prvni_volna;
        int * bunky;
    };
    struct FILO vytvor(int n){
        return {0, malloc(n*sizeof(int))}
    }
    void vloz(struct FILO * f, int p){
        f->bunky[f->prvni_volna++] = p;
    }
    int vezmi(struct FILO * f){
        return f->bunky[--f->prvni_volna];
    }


V této kapitole se budeme věnovat hlavně datovým strukturám v RAM modelu. Takže stále matematickým popisům, při diskusi výhod a nevýhod bude někdy
nutné podívat se na možnosti implementace na reálných počítačích, protože ač může vypadat nějaká datová struktura dobře svými vlastnostmi,
např. nejlepší časová složitost, hardwarová implementace dnešních počítačů je lepší pro matematicky méně optimální funkce.


.Section Lineární datové struktury
  label: sec-linear-datastructures


.Definition:
  title: Pole
  label: def-pole
  index: pole

  Není pole jako pole. Na tomto se rostliny nepěstují ani po něm traktor nejezdí. Je to nejjednodužžší
  datová struktura. Řada buňek za sebou. Do kterých můžeme přistupovat a modifikovat jejich obsah.

  
  Přístup i modifikaci prvků máme za $\lanO(1)$ jak v čase tak paměti. Přistupovat však můžeme pouze na index,
  pokud bychom potřebovali určitý prvek, tak budeme nuceni použít nějaký algoritmus z sekce .reference:sec-vyhledavaci-algo.


  Jeho implementace najdete v C jako "int[]".code, v Rustu "[u32; n]".code nebo Array v Csharp.


% TODO vymyslet jak psát C#


Pole je dobrý kamarád dokud víme předem, kolik prvků bude potřeba, když to ale nevíme tak potřebujeme něco lepšího.


.Definition:
  title: Nafukovací pole
  label: def-nafukovaci-pole
  index: nafukovací pole

  "Nafukovací pole".notion je pole, do kterého můžeme přistupovat na index za konstantní čas. Narozdíl od klasického pole však,
  nemusíme předem specifikovat velikost a můžeme do pole přidávat prvky. Prvky na konec vkládáme za amortizovaně konstantní čas.
  Kamkoli jinam za $\lanO(n)$


  Je to "list".code co znáte z Pythonu nebo vektory z C++ a Rustu.


.Definition:
  title: Spojový seznam
  english: Linked list
  index:
    - spojový seznam
    - linked list
  label: def-spojovy-seznam

  Spojový seznam umožňuje vkládání kamkoli za $\lanO(1)$. Ale přístup na index je za $\lanO(n)$


  V Rustu "std::collections::LinkedList".code a "std::list".code v C++.


.Definition:
  title: Zásobník
  english: Stack
  index:
    - zásobník
    - stack
  label: def-stack

  Zásobník neboli stack je jednoduchá struktura, umožňuje vložit prvek za $\lanO(1)$ a vyzvednout prvek, opět za $\lanO(1)$.
  Prvky se vyzvedávají v opačném pořadí od vložení.


.Definition:
  title: Fronta
  english: Queue
  index:
    - fronta
    - queue
  label: def-queue

  Fronta se chová podobně jako zásobník, také umožňuje vložit a vyzvednout prvek za $\lanO(1)$, ovšem prvky
  se vyzvedávají v pořadí v jakém se do fronty dostaly.

% Pole, nafukovací pole, spoják, stack, fronta, kruhový buffer, deque


.Section Hashování v datových strukturách
  label: sec-hash-in-datastractures


S pojmem hashování jste se spíše setkali v kontextu bezpečnosti, použít se však dá i v datových strukturách. Hashování je způsob
jak objekty, které nejsou jednoduše porovnatelné mezi sebou uspořádat tak, aby se dali rychle najít.


Aby se v datech dala data dobře najít, tak si je ukládáme do tabulky. Pomocí hashovací funkce pak zjistíme, kam objekt strčit nebo kde ho hledat.


.Definition:
  title: Hashovací funkce
  index: hashovací funkce
  label: def-hash-fun

  Obecná hashovací funkce je $f\colon \UU \to \PP$ přiřadí každému objektu v univezu $\UU$ nějakou přihrádku v $\PP$.

  
  Prakticky to bude spíše $f\colon \UU \to \N$, kde se každému objektu přiřadí nějaké přirozené číslo a další funkce (třeba modulo počet přihrádek)
  z čísla zjistí přihrádku.


Celkem pěkný materiál, zatímco je Fiksařka ve vývinu je "tady".reference.1
  1:
    link: https://www.algoritmy.net/article/32077/Hashovaci-tabulka


.Definition:
  title: Hash set
  index: hash!set
  label: def-hash-set

  Hash set je datová struktura reprezentující množinu, která zvládne vložit a odebrat prvek za $\lanO^*(1)$.
  Také umí odpovědět, zda se prvek v množině nachází za $\lanO^*(1)$.


  Naleznete ho jako "std::unoredered_set".code v C++, "std::collections::HashSet".code v Rustu nebo "set".code v Pythonu.


.Definition:
  title: Hash map
  index: hash!map
  label: def-hash-map

  Hash map je datová struktura, která ukládá dvojice $(\text{klíč}, \text{hodnota})$. Vložit je potřeba klíč s hodnotou za $\lanO^*(1)$.
  Na hodnotu se pak můžeme zeptat pouze za pomoci klíče opět za $\lanO^*(1)$. Hodnotu ke klíči můžeme změnit také za $\lanO^*(1)$.

  Naleznete ho jako "std::unoredered_map".code v C++, "std::collections::HashMap".code v Rustu nebo "dict".code v Pythonu.

% Hashtable, hashmap, dobré hashovací funkce


.Section Stromové struktury
  label: sec-tree-structures


Nějkteré datové struktury využívají "grafy"#def-neorientovany-graf pro ukládání dat. V této sekci se zaměříme na ty, které využívají stromy.


.Definition:
  title: Vyhledávací strom
  english: Search tree
  label: def-search-tree
  index: vyhledávací strom

  Vyhledávací strom, je zakořeněný strom. Který má ve vrcholech uložené prvky. Uložení těchto prvků splňuje nějaký invariant, takže se dají rychle najít.


To je pěkná definice, ale moc nám toho neřekne, pojďme se podívat na nějaký konkrétní příklad.


.Definition:
  title: Binární vyhledávací strom
  english: Binary search tree
  label: def-bst
  index: vyhledávací strom!binární

  "Binární vyhledávací strom".notion (BVS nebo BST) je zakořeněný strom, kde každý vrchol má nejvýše dva syny, levého a pravého. A pro všechny vrcholy $v$ a prvky v nich uložené
  platí $v_l < v < v_r$, kde $v_l$ a $v_r$ jsou levý a pravý syn vrcholu $v$.


  Vyhledání prvku pak začne v kořeni a porovná hledaný prvek s prvkem v koření, pokud je prvek v kořeni tak skončí, že je prvek nalezen. Pokud je hledaný prvek
  rekurzivně se provede na levém synovi, pokud je větší tak na pravém. Pokud vrchol nemá syna, na kterém se má algoritmus rekurzivně provézt, tak skončí s informací,
  že prvek se ve stromě nenachází.


  Vkládání je podobné jako vyhledávání, pokud je prvek nalezen, tak se nic nevloží. Když se algoritmus dostane k vrcholu, který nemá syna v jehož podstromě by měl
  hledat, tak vloží prvek jako tohoto syna.


  Mazání je náročnější, opět se provede stejný algoritmus jako při vyhledávání, pokud se nic nenajde, nemusí se nic mazat. Pak jsou tři možnosti, co může nastat.

  .itemize:

    .item:
      
      "Mazaný vrchol je list".emphasize, pak se smaže bez problémů.

    .item:

      "Mazaný vrchol má pouze jednoho syna".emphasize pak vrchol smažeme a jeho syna umístíme na jeho místo.

    .item:

      "Mazaný vrchol má dva syny".emphasize pak určitě exituje vrchol v jeho pravém podstomu nějaký nejmenší prvek, který nemá levého syna (kdyby měl, tak bude menší)
      může tedy jejich obsah vyměnit a nyní maže vrchol, který má pouze jednoho syna.


TODO složitost + nevýhoda nevyváženého


.Definition:
  title: Vyvážený binární vyhledávací strom
  english: Balanced binary search tree
  label: def-balanced-bst
  index: vyhledávací strom!vyvážený binární

  Binární vyhledávací strom je "vyvážený".notion pokud pro každý jeho vrchol platí, že rozdíl velikostí levého a pravého podstromu je nanejvýše jedna.


.Definition:
  title: Hloubkově vyvážený binární vyhledávací strom
  english: Height balanced binary search tree
  label: def-height-balanced-bst
  index: vyhledávací strom!hloubkově vyvážený binární

  Binární vyhledávací strom je "hloubkově vyvážený".notion pokud pro každý jeho vrchol platí, že rozdíl hloubek levého a pravého podstromu je nanejvýše jedna.


.Definition:
  title: Samovyvažující se strom
  english: Selfbalancing tree
  label: def-selfbalancing-tree
  index: vyhledávací strom!samovyvažující se

  Vyhledávací strom je "samovyvažující se".notion pokud zůstane po všech možných posloupnostích operací na něm provedených (hloubkově) vyvážený.


.Definition:
  title: AVL strom
  label: def-avl-tree
  index: vyhledávací strom!AVL

  "AVL-strom".notion je samovyvažující se binární vyhledávací strom. Jméno nese po autorech,
  kterými jsou "Georgij Maximovič Aděľson-Veľskij".emphasize a "Jevgenij Michailovič Landis".emphasize.


  Protože vyhledávání nemění tvar stromu, tak může použít stejný algoritmus jako u jednoduchého "BVS"#def-bst. Během vkládání
  a mazání už se tvar mění a může dojít k porušení vyváženosti. Napravit se dá pomocí dvou operací levé a pravé rotace.


  Pravá rotace na vrcholu $x$ vypadá takto.

  
  !dot:
    filename: dot-avl-rightrotate0

    digraph AVL {
      bgcolor="transparent";
      rankdir=TD;
      ordering="in";
      S -> x;
      S0 -> y0;
      x -> {y C} 
      y -> {A B}
      y0 -> A0
      y0 -> x0
      x0 -> {B0 C0}
      {rank=same; y; C; A0; x0;}
      {rank=same; A; B; B0; C0;}
      y[label="y", style="filled", fillcolor="#00b4e9"]
      A[label="A", style="filled", fillcolor="#e6e6ff"]
      x[label="x", style="filled", fillcolor="lime"]
      B[label="B", style="filled", fillcolor="#e6e6ff"]
      C[label="C", style="filled", fillcolor="#e6e6ff"]
      y0[label="y", style="filled", fillcolor="#00b4e9"]
      A0[label="A", style="filled", fillcolor="#e6e6ff"]
      x0[label="x", style="filled", fillcolor="lime"]
      B0[label="B", style="filled", fillcolor="#e6e6ff"]
      C0[label="C", style="filled", fillcolor="#e6e6ff"]
      S[style=invis]
      S0[style=invis]
    }


  Naopak rotace doleva vypadá takto


  !dot:
    filename: dot-avl-leftrotate

    digraph AVL {
      bgcolor="transparent";
      rankdir=TD;
      ordering="in";
      S -> x;
      S0 -> y0;
      x -> {A y} 
      y -> {B C}
      y0 -> {x0 C0}
      x0 -> {A0 B0}
      {rank=same; y; A; x0; C0;}
      {rank=same; B; C; A0; B0;}
      y[label="y", style="filled", fillcolor="#00b4e9"]
      A[label="A", style="filled", fillcolor="#e6e6ff"]
      x[label="x", style="filled", fillcolor="lime"]
      B[label="B", style="filled", fillcolor="#e6e6ff"]
      C[label="C", style="filled", fillcolor="#e6e6ff"]
      y0[label="y", style="filled", fillcolor="#00b4e9"]
      A0[label="A", style="filled", fillcolor="#e6e6ff"]
      x0[label="x", style="filled", fillcolor="lime"]
      B0[label="B", style="filled", fillcolor="#e6e6ff"]
      C0[label="C", style="filled", fillcolor="#e6e6ff"]
      S[style=invis]
      S0[style=invis]
    }


  Tyto dvě operace nám pomohou zbavit se nevyváženosti. V každém vrcholu je hodnota $\delta$ určující rozdíl hloubky levého
  a pravého podstromu. Pokud je $|\delta| < 2$ pak vrchol splňuje podmínku hloubkové vyváženosti. Pokud $|\delta| = 2$
  "všiměte si, že jiná situace nemůže nastat".footnote, tak je potřeba strom vyvážit. Nejjednodušší situace je, když je "přetížen".quoted
  doleva nebo doprava, tedy že $\textrm{sign}(\delta(x)) = \textrm{sign}(\delta(s))$, kde $s$ je kořen hlubšího podstromu.
  Pak se provede pravá rotace, pokud je levý podstrom hlubší, levá v opačném případě.


  Pokud nenastala tato situace jsou potřeba rotace dvě.

  !dot:
    filename: avl-leftrigtrotate0

    digraph AVL {
      bgcolor="transparent";
      rankdir=TD;
      ordering="in";
      S -> x;
      x -> {y D} 
      y -> {A z}
      z -> {B C}
      {rank=same; y; D;}
      {rank=same; A; z;}
      {rank=same; B; C;}
      y[label="y", style="filled", fillcolor="#00b4e9", xlabel="-1", xlabelfontcolor="blue"]
      A[label="A", style="filled", fillcolor="#e6e6ff"]
      x[label="x", style="filled", fillcolor="lime", xlabel="+2", xlabelfontcolor="blue"]
      y[label="y", style="filled", fillcolor="yellow", xlabel="", xlabelfontcolor="blue"]
      B[label="B", style="filled", fillcolor="#e6e6ff"]
      C[label="C", style="filled", fillcolor="#e6e6ff"]
      S[style=invis]
    }


  Nějak jsem zmátl sám sebe.... TODO


% BST, AVL, Redblack, Binary heap, AB-strom


% .Section Kombinované struktury
%   label: sec-combined-structures
%
%
% priority queue

.Section Disjoint Set Union
  label: sec-dsu


Strukturu Disjoint Set Union (zkráceně "DSU".notion) si představíme v následujícím problému:


.Question:
  title: Pražská ZOO

  V pražské ZOO najdeme velké množství zvířat. Od papoušků, přes pakoně, až po exotické lední
  medvědy či kiwi. Všechna zvířata jsou zavřená v pavilonech, kde se na ně můžou
  dívat zvědavé děti s rodičemi. Vedení pražské ZOO chce turistům usnadnit pohyb v zoo, proto
  semtam přistaví mezi některými pavilony cestu (po které se lze pohybovat tam i zpět).


  Přestože zvířata vypadají přes den celkem poklidně, jakmile se odpoledne zavřou vrata
  za poslední rodinou, vypukne chaos. Zvířátka jsou totiž celkem chytrá, takže si dokážou
  své pavilony zevnitř samozřejmě otevřít.


  Večer zvířáta pořádají turnaje v tom, kdo je nejsilnější.
  Turnajů se může za jeden konat víc, protože ne všechna zvířata můžou mezi sebou soutěžit.
  Řekneme, že zvířata z pavilonů X a Y mezi sebou můžou soutěžit, pokud pavilony X a Y jsou
  spojeny cestou, nebo pokud existuje pavilon Z takový, že pavilony X a Z jsou spojeny
  cestou a zvířata Z a Y mezi sebou můžou
  soutěžit"všimněte si, že toto je rekurzivní definice".footnote. Pro každý turnaj nás zajímá
  jeho výherce, tedy nejsilnější zvíře mezi zvířaty, které v daném turnaji mohli soutěžit.


  Vaším úkolem je vymyslet datovou strukturu, která bude podporovat následující operace:


  !codeblock:
    language: cpp

    struct VašeStruktura {
      void přidejCestu(Pavilon X, Pavilon Y); // vytvoří cestu mezi pavilony X a Y
      void přidejPavilon(Pavilon P, Zvíře Z); // vytvoří nový pavilon P a přidá do něj zvíře Z
      void vypišVýherce(); // vypíše výherce ze všech turnajů
    };


.Definition:
  title: DSU
  label: def-dsu
  index: dsu

  DSU je datová struktura s následujícím rozhraním:


  !codeblock:
    language: cpp

    void makeSet(Element v); // vytvoří novou množinu s jediním prvkem `v`
    void unionSets(Element v, Element u); // sjednotí množiny obsahující prvek `v`, resp. prvek `u`
    Element findSet(Element v); // najde reprezenta množiny, do které prvek `v` patří


.Subsection Reprezentace DSU
  label: subsec-reprezentace-dsu

Každou množinu si reprezentujeme jako tzv. "keř".notion, což je strom orientovaný směrem
do kořene. Každý prvek v keři odkazuje na svého (jediného) otce, až na vrchol keře,
který ukazuje sám na sebe. Hloubku keře $K$ označíme $h(K)$ a počet prvků $|K|$.
"Reprezentantem množiny".notion pak chápeme prvek ve vrcholu svědčícího keře.


!codeblock:
  language: cpp

  class DSU {
    map<Element, Element> parent; // tabulka, kde hodnotou je otec klíče
  public:
    void makeSet(Element v);
    void unionSets(Element v, Element u);
    Element findSet(Element v);
  };


.Procedure:
  title: Implementace operace "makeSet".code
  label: algo-dsu-makeset

  Operace "makeSet".code vytvoří novou množinu o jediném prvku předaným argumentem
  a tento prvek vloží jako reprezentanta do tabulky "parent".code.


  !codeblock:
    language: cpp

    void DSU::makeSet(Element v) {
      parent[v] = v;
    }


.Procedure:
  title: Implementace operace "findSet".code
  label: algo-dsu-simple-findset

  Operace "findSet".code pro zadaný prvek najde reprezentanta množiny, ve které se prvek
  vyskytuje.


  !codeblock:
    language: cpp

    Element DSU::findSet(Element v) {
      while (parent[v] != v) {
        v = parent[v];
      }
      return v;
    }


.Procedure:
  title: Implementace operace "unionSets".code
  label: algo-dsu-simple-unionsets

  Operace "unionSets".code najde pro zadané prvky reprezentanty množin, ve kterých se respektive
  nacházejí. Pokud oba prvky mají stejného reprezentanta, pak leží ve stejné množině, a tedy
  není co sjednocovat. Jinak jednomu z reprezentantů nastaví v poli "parent".code
  jako otce druhého z reprezentantů.


  !codeblock:
    language: cpp

    void DSU::unionSets(Element v, Element u) {
      Element represent_v = findSet(v);
      Element represent_u = findSet(u);
      if (represent_v == represent_u) return;
      parent[represent_v] = represent_u;
    }


.Lemma:
  title: O hloubce DSU
  label: lemma-dsu-simple-depth

  Po každé provedené operaci pro keř $K$ platí, že $h(K) = \Theta(|K|)$.


.Proof:

  Operace "findSet".code DSU neupravuje, vztah hloubky tedy bude zachován.
  "makeSet".code vytvoří nový keř, pro který tvrzení platí.


  Pro důkaz dolního odhadu"tedy že $h(K) = \Omega(|K|)$".footnote uvažme $|K|$ jednoprvkových
  keřů, které vznikly postupným voláním operace "makeSet".code. Označme první keř $K$ a postupně
  k němu přidávejme další keře voláním "unionSets(K,_)".code. Vrchol keře $K$ se postupně
  zapojí za všechny jednoprvkové vrcholy ostatních keřů, a tedy $h(K) = |K| = \Omega(|K|)$.


  Horní odhad je triviální, neboť keř dosahuje největší hloubky právě tehdy, když je cestou"rozmyslete!".footnote,
  a tedy $h(K) = \lanO(|K|)$.


.Procedure:
  title: Efektivní implementace operace "unionSets".code
  label: algo-dsu-unionsets

  Lineární hloubka keře vůči počtu prvků není zrovna nejlepší. Problémem je
  operace "unionSets".code"jak víme z předchozího důkazu".footnote. Konkrétně, že můžeme zapojovat keře s větší hloubkou za keře s menší hloubkou.
  Může nás napadnout, že když budeme chtít spojit dvě množiny, porovnáme nejrpve hloubku obou keřů
  a poté zapojíme ten s menší hloubkou za ten s větší.


  !codeblock:
    language: cpp

    void DSU::unionSets(Element v, Element u) {
      Element represent_v = findSet(v);
      Element represent_u = findSet(u);
      if (represent_v == represent_u) return;
      if (rank[u] < rank[v]) swap(u, v);
      parent[represent_v] = represent_u;
      if (rank[u] == rank[v]) { // hodnota rank[v] drží hloubku podstromu s vrcholem v
        rank[represent_u] = rank[reprsent_u] + 1; // prohlub keř
      }
    }


Jak moc se hloubka keře zlepší, když si toto v kódu ohlídáme? Ukáže se, že značně.


.Theorem:
  title: O hloubce DSU s efektivní implementací operací "unionSets".code
  label: theorem-dsu-depth-unionsets

  Po každé provedené operaci platí, že má-li keř $K$ v DSU $n$ prvků, pak $h(K) = O(\log(n))$.


.Proof:

  TODO


.Procedure:
  title: Efektivní implementace operace "findSet".code
  label: subsec-dsu-findset

  Další optimalizací může být lehká uprava operace "findSet".code. Vždy, když hledáme reprezentanta
  procházíme všechny prvky na cestě mezi zadaným prvkem a vrcholem keře. Tyto prvky můžeme postupně přepojit
  všechny za vrchol keře, a tím teoreticky snížit hloubku keře. Této optimalizaci se říká "path compression".notion
  a protože hloubku nikdy nezvětšíme, platí předchozí věta i s touto operací.


  !codeblock:
    language: cpp

    Element DSU::findSet(Element v) {
      if (v == parent[v]) return v;
      return parent[v] = findSet(parent[v]); // poslední volání je stejná operace => tail rekurze
    }


.Corollary:
  title: O hloubce DSU s efektivní implementací operací "unionSets".code a "findSet".code
  label: corollary-dsu-depth-unionsets-and-findset

  Po každé provedé operaci platí, že má-li keř $K$ v DSU $n$ prvků, pak $h(K) = O(\log(n))$.


.Theorem:
  title: O průměrné hloubce DSU s efektivní implementací operací "unionSets".code a "findSet".code
  label: lemma-dsu-path-compression-depth

  Po každé provedené operaci platí, že má-li keř $K$ v DSU $n$ prvků, pak v průměrném případě
  $h(K) = O(\alpha(n))$, kde $\alpha(n)$ je Ackermannova funkce.


.Proof:

  Vynecháváme.


.Remark:

  Přestože rekurzivní funkce jsou často paměťově neefektivní kvůli velkému
  počtu stackframů, tento případ se neaplikuje na operaci "findSet".code. Důvodem je to,
  že rekurzivní call je poslendím voláním této funkce. Tomuto způsobu rekurze se říká "tail rekurze".notion"dále máme např. lineární nebo značně neefektivní stromovou rekurzi".footnote
  a kompilátor nad ní může provést značně podstatnou optimalizaci, protože si nemusí pamatovat stackframe,
  ze kterého byl rekurznivní call proveden. Více se můžete dočíst například "zde"@1.
    1:
      link: 'https://en.wikipedia.org/wiki/Tail_call'


.Section Pokročilé datové struktury
  label: sec-advanced-datastructures


Segtree, Fenwic tree, Trie
