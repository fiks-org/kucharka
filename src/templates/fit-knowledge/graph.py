import hashlib
import json
import sys

import networkx as nx
import networkx.drawing.nx_agraph
from networkx.readwrite import json_graph

NODE_WEIGHT = "weight"


def load_data(path):
    """
    :param path: Path to file containing json data
    :return: Returns dictionary with data in path
    """
    f = open(path, encoding='utf-8')
    return json.load(f)


def apply_layout(di_graph):
    """
    :param di_graph: Directional graph
    :return: Directional graph with applied layout
    """

    di_graph.graph.update({
        "splines": False,
        "mclimit": 100,
    })
    pr = nx.pagerank(di_graph)
    pr = {key: pr[key] ** 0.33 for key in pr}  # normalize
    if len(pr) == 1:
        pr = {key: 50 for key in pr}
    else:
        pr = {key: ((pr[key] - min(pr.values())) / (max(pr.values()) - min(pr.values()))) * 100 for key in pr}  # normalize
    nx.set_node_attributes(di_graph, pr, name=NODE_WEIGHT)

    A = networkx.drawing.nx_agraph.to_agraph(di_graph)
    A.layout('dot')
    dot_graph = networkx.drawing.nx_agraph.from_agraph(A)
    # A.draw('layout.pdf', format='pdf')
    return json_graph.node_link_data(dot_graph)


def generate_graph_from_data(data):
    """
    Generages Directional Graph from data
    :param data: Array of dictionaries with following keys: label (string id of node), points_to (array of references to another nodes)
    :return: networkx directional graph
    """

    def add_edge(G, source, target, weight):
        if any(node['label'] == target for node in data):
            G.add_edge(source, target, weight=weight)

    d = dict()
    G = nx.DiGraph()
    for i in data:
        d[i['label']] = i['points_to']
        width_randomizer = ((int(hashlib.md5(i['label'].encode('utf-8')).hexdigest(), 16) % 2000) - 1000) / 100
        G.add_node(i['label'], fixedsize=True, height=20, width=25 + width_randomizer)
    for i in data:
        for ref in i['points_to']:
            add_edge(G, i['label'], ref, 1)
        for ref in i['proof_requires']:
            add_edge(G, i['label'], ref, 5)
    return G


def loaded_data_to_dict(loaded_data):
    """
    Converts loadedData array to dictionary with label as key
    :param loaded_data: Array of nodes
    :return: Dictionary { label => node }
    """
    result = dict()
    for entry in loaded_data:
        if entry['label'] in result:
            raise ValueError("Duplicate label {0} found".format(entry['label']))
        result[entry['label']] = entry
    return result


def prepare_output_data(graph_data, all_data):
    """
    Applies layout in graphData to loadedData
    :param all_data: Data loaded from file generated by Ruby part of this template
    :param graph_data: Graph specifying the layout of nodes
    :return: Dictionary with canvas and nodes keys. Canvas contains size of the graph, nodes contain loaded nodes with position
    """

    def parse_position(str):
        SEPARATOR = ','
        if str.count(SEPARATOR) == 3:
            x = str.split(SEPARATOR)[2]
            y = str.split(SEPARATOR)[3]
        elif str.count(SEPARATOR) == 1:
            x = str.split(SEPARATOR)[0]
            y = str.split(SEPARATOR)[1]
        else:
            raise Exception("Invalid position type")
        return {"x": round(float(x)), "y": round(float(y))}

    loaded_data_dict = loaded_data_to_dict(all_data['data'])
    output = dict()
    # Canvas size
    output['canvas'] = parse_position(graph_data["graph"]["bb"])
    output['timestamp'] = all_data['timestamp']
    output['meta'] = all_data['meta']
    nodes = dict()
    # Combines node position from graph and node data from loaded data
    for graph_node in graph_data["nodes"]:
        try:
            node = {**parse_position(graph_node["pos"]),
                    **loaded_data_dict[graph_node['id']],
                    "weight": graph_node[NODE_WEIGHT]
                    }
        except KeyError:
            raise ValueError("loaded_data does not contain '{0}' key".format(graph_node['id']))
        nodes[graph_node['id']] = node
    output['nodes'] = nodes
    return output


if __name__ == '__main__':
    if not len(sys.argv) == 3:
        print("Invalid parameter count.\nUsage: [INPUT_FILE] [OUTPUT_FILE]")
        exit(2)

    all_data = load_data(sys.argv[1])
    data = all_data['data']
    G = generate_graph_from_data(data)
    graph = apply_layout(G)
    output = prepare_output_data(graph, all_data)
    with open(sys.argv[2], "w") as outfile:
        json.dump(output, outfile, ensure_ascii=False)
